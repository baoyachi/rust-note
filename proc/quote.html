<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>quote - rust-note</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/pagetoc.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> README</a></li><li class="chapter-item expanded "><a href="../proc-macro-note.html"><strong aria-hidden="true">2.</strong> 过程宏</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../proc/ref.html"><strong aria-hidden="true">2.1.</strong> 基础内容</a></li><li class="chapter-item expanded "><a href="../proc/quote.html" class="active"><strong aria-hidden="true">2.2.</strong> quote</a></li><li class="chapter-item expanded "><a href="../proc/syn.html"><strong aria-hidden="true">2.3.</strong> syn</a></li><li class="chapter-item expanded "><a href="../proc/proc_macro2.html"><strong aria-hidden="true">2.4.</strong> proc_macro2</a></li><li class="chapter-item expanded "><a href="../proc/study-case.html"><strong aria-hidden="true">2.5.</strong> 案例</a></li><li class="chapter-item expanded "><a href="../proc/debug.html"><strong aria-hidden="true">2.6.</strong> 调试</a></li><li class="chapter-item expanded "><a href="../proc/FAQ.html"><strong aria-hidden="true">2.7.</strong> FAQ</a></li></ol></li><li class="chapter-item expanded "><a href="../dcl.html"><strong aria-hidden="true">3.</strong> 声明宏案例</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dcl/variadic.html"><strong aria-hidden="true">3.1.</strong> “变长参数”函数与回调</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> non-lexical lifetimes (NLL)</div></li><li class="chapter-item expanded "><a href="../subtyping.html"><strong aria-hidden="true">5.</strong> Subtyping and Variance</a></li><li class="chapter-item expanded "><a href="../forum.html"><strong aria-hidden="true">6.</strong> 官方论坛帖子整理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../forum/homo-variant.html"><strong aria-hidden="true">6.1.</strong> 从同质 variants 取同类型数据</a></li><li class="chapter-item expanded "><a href="../forum/impl-const-param.html"><strong aria-hidden="true">6.2.</strong> 常量泛型参数的分类实现</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rust-note</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/zjp-CN/rust-note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <h1 id="quote"><a class="header" href="#quote"><code>quote</code></a></h1>
<p>这里主要结合编写经验来总结 quote 的使用方式，大部分内容是对 quote 文档的翻译和重新组织。</p>
<p>如果内容上有出入，请以 quote 文档为准。</p>
<h2 id="基础知识"><a class="header" href="#基础知识">基础知识</a></h2>
<p>Rust 的过程宏所做的事情就是：</p>
<ol>
<li>从<abbr title="input">输入</abbr>中获取<abbr title="a stream of tokens">标记流</abbr>；</li>
<li>处理甚至生成标记流；</li>
<li>把处理过的或者新的标记流传回编译器；</li>
<li>编译器将这些标记流编译进调用者的 crate。</li>
</ol>
<p><a href="https://docs.rs/quote"><code>quote</code></a> crate 把 Rust 语法树的数据结构转化为源代码的标记 
(tokens)，在上述过程中，<code>quote</code> 在生成标记并返回给编辑器的环节提供了一种解决方案。</p>
<p><code>quote</code> 提出一种概念 quasi-quoting<sup class="footnote-reference"><a href="#quasi-quoting">1</a></sup>
，把我们所编写的代码视为数据。从而让我们写出看起来像是文本编辑器或者 
IDE 里的那种代码：写这种代码时让我们享受到 IDE 提供的大括号匹配、语法突出显示、缩进以及自动补全等功能。</p>
<p>但是这种代码不直接编译到当前 crate 
中，编写它们就像处理数据一样，我们可以传递、改变这些数据，最后把它们当作标记传回编译器，编译进调用者的 crate。</p>
<div class="footnote-definition" id="quasi-quoting"><sup class="footnote-definition-label">1</sup>
<p>直白翻译为“类引述”、“类引用”。我的理解为，“写起来像原来的代码一样”。quoting 取 
&quot;repeat or copy out (words from a text or speech written or spoken by another person)&quot; 本义 —— 重复、复制。</p>
</div>
<p>一个例子是 <a href="https://serde.rs/"><code>serde</code></a> crate 提供的过程宏，它使用类似于下面的代码：<code>quote!</code>
内的代码看起来像我们在 IDE 中所写的那种代码，但使用 <code>#var</code>
进行插值（把运行时的变量插入到相应位置上），这在形式上如同声明宏的 <code>$var</code> 插值。</p>
<pre><code class="language-rust ignore">let tokens = quote! {
    struct SerializeWith #generics #where_clause {
        value: &amp;'a #field_ty,
        phantom: core::marker::PhantomData&lt;#item_ty&gt;,
    }

    impl #generics serde::Serialize for SerializeWith #generics #where_clause {
       fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
        where
            S: serde::Serializer,
        {
<span class="boring">            path(self.value, serializer)
</span>        }
    }

    SerializeWith {
        value: #value,
        phantom: core::marker::PhantomData::&lt;#item_ty&gt;,
    }
}; 
</code></pre>
<p>此外，<code>quote</code> 虽然受过程宏用例驱动开发，但它实际是可实现通用目的的 Rust 库，并不特定于过程性宏。</p>
<p><code>quote</code> 有三个宏和三个 trait。</p>
<p>其中 <a href="https://docs.rs/quote/latest/quote/trait.TokenStreamExt.html"><code>TokenStreamExt</code></a> 仅仅是对 <a href="https://docs.rs/proc-macro2/*/proc_macro2/struct.TokenStream.html"><code>TokenStream</code></a>
提供一些封装的、内部使用的方法，它的设计模式可参考
<a href="https://zjp-cn.github.io/api-guidelines/future-proofing.html#%E5%B0%81%E8%A3%85%E7%9A%84-traits-%E9%9A%94%E7%BB%9D%E4%B8%8B%E6%B8%B8%E7%9A%84%E5%AE%9E%E7%8E%B0">此处说明</a>。</p>
<h2 id="format_ident-与-identfragment-trait"><a class="header" href="#format_ident-与-identfragment-trait"><code>format_ident!</code> 与 <code>IdentFragment</code> trait</a></h2>
<p>它们用于拼接标识符。</p>
<p>与 <a href="https://doc.rust-lang.org/nightly/alloc/macro.format.html"><code>format!</code></a> 类似，
<a href="https://docs.rs/quote/*/quote/macro.format_ident.html"><code>format_ident!</code></a> 具有以下功能，比如：</p>
<ol>
<li>除了 <code>{}</code> 插值，还支持位置参数和命名参数插值，如 <code>format_ident!(&quot;{0}&quot;, arg)</code> 和 <code>format_ident!(&quot;{arg}&quot;, arg)</code></li>
<li>支持一些有限的<a href="https://doc.rust-lang.org/nightly/alloc/fmt/index.html">格式化</a>的方式：
<ul>
<li><code>{}</code> ⇒ 按照 <a href="https://docs.rs/quote/*/quote/trait.IdentFragment.html"><code>IdentFragment</code></a> 格式化</li>
<li><code>{:o}</code> ⇒ <a href="%60std::fmt::Octal%60"><code>Octal</code></a> 八进制格式化</li>
<li><code>{:x}</code> ⇒ <a href="%60std::fmt::LowerHex%60"><code>LowerHex</code></a> 小写字母格式化</li>
<li><code>{:X}</code> ⇒ <a href="%60std::fmt::UpperHex%60"><code>UpperHex</code></a> 大写字母格式化</li>
<li><code>{:b}</code> ⇒ <a href="%60std::fmt::Binary%60"><code>Binary</code></a> 二进制格式化</li>
</ul>
<pre><code class="language-rust ignore">let num: u32 = 10;

let decimal = format_ident!(&quot;Id_{}&quot;, num);
assert_eq!(decimal, &quot;Id_10&quot;);

let octal = format_ident!(&quot;Id_{:o}&quot;, num);
assert_eq!(octal, &quot;Id_12&quot;);

let binary = format_ident!(&quot;Id_{:b}&quot;, num);
assert_eq!(binary, &quot;Id_1010&quot;);

let lower_hex = format_ident!(&quot;Id_{:x}&quot;, num);
assert_eq!(lower_hex, &quot;Id_a&quot;);

let upper_hex = format_ident!(&quot;Id_{:X}&quot;, num);
assert_eq!(upper_hex, &quot;Id_A&quot;);
</code></pre>
</li>
</ol>
<p>但它也与 <code>format!</code> 不同，因为：</p>
<ol>
<li><code>format!</code> 使用 <code>Display</code> 方式格式化 <code>{}</code>，而 <code>format_ident!</code> 使用 <code>IdentFragment</code>，而
<code>IdentFragment</code> trait 只对有限的类型实现，比如无符号整数和字符串</li>
<li><a href="https://docs.rs/proc-macro2/*/proc_macro2/struct.Ident.html"><code>Ident</code></a> 参数如果存在 <code>r#</code> 前缀的话，会把 <code>r#</code> 去除掉（由 <code>IdentFragment</code> 提供的）</li>
<li><code>format_ident!</code> 的结果为 <a href="https://docs.rs/proc-macro2/*/proc_macro2/struct.Ident.html"><code>Ident</code></a> 类型，而不是 <code>String</code> 类型。<code>Ident</code> 与任何实现
<code>AsRef&lt;str&gt;</code> 的类型<a href="https://docs.rs/proc-macro2/*/proc_macro2/struct.Ident.html#impl-PartialEq%3CT%3E">可以比较相等</a></li>
</ol>
<p>标识符 <code>Ident</code> 类型表示 Rust 代码的一个
<abbr title="word">字</abbr>，可能是关键字或合法的变量名。标识符至少由一个
Unicode 代码点组成，其中第一个代码点具有 <code>XID_Start</code> 属性，其余代码点具有 <code>XID_Continue</code>
属性。注意：</p>
<ul>
<li>空字符串 <code>&quot;&quot;</code> 不是标识符，应该使用 <code>Option&lt;Ident&gt;</code> 表示它。</li>
<li>生命周期不是标识符，应该使用 <code>syn::Lifetime</code>。</li>
</ul>
<p>除了使用 <code>quote::format_ident!</code>，你还可以直接使用 <code>proc_macro2</code> 或者 <code>syn</code><sup class="footnote-reference"><a href="#Ident">2</a></sup> 里的 <code>Ident::new(&amp;str, Span::call_site())</code>
构造任意 Rust 标识符（包括关键字）。但 <code>format_ident!</code> 与后者方式的区别在于，<code>format_ident!</code> 
可以构造出<abbr title="raw identifier">原生字符串</abbr> <code>r#</code>。</p>
<p>在解析标识符时：</p>
<ol>
<li><a href="https://docs.rs/syn/*/syn/parse/trait.Parse.html"><code>syn::parse</code></a> 可以解析 Rust 关键字之外的标识符。</li>
<li>通过 <code>input.call(syn::Ident::parse_any)</code> 方式可以达到解析任意标识符（包括关键字）的目的。</li>
<li>通过 <code>input.call(syn::Ident::unraw)</code> 方式可以达到去除 <code>r#</code> 前缀的目的。</li>
</ol>
<div class="footnote-definition" id="input"><sup class="footnote-definition-label">3</sup>
<p><a href="https://docs.rs/proc-macro2/*/proc_macro2/struct.Ident.html"><code>proc_macro2::Ident</code></a>、
<a href="https://doc.rust-lang.org/proc_macro/struct.Ident.html"><code>proc_macro::Ident</code></a> 和
<a href="https://docs.rs/syn/*/syn/struct.Ident.html"><code>syn::Ident</code></a> 都定义了类似的数据结构。</p>
</div>
<p>从 <code>Ident::new</code> 的签名中，可以看到，构造标识符需要提供第二个参数 <a href="https://docs.rs/proc-macro2/*/proc_macro2/struct.Span.html"><code>Span</code></a>
，它表示源代码的区域范围，意味着标识符在某个范围内的“<abbr title="hygiene">卫生性</abbr>”。
<code>format_ident!</code> 在这方面有如下说明：</p>
<ul>
<li>最后创建的标识符使用第一个 <code>Ident</code> 参数的范围</li>
</ul>
<pre><code class="language-rust ignore">// 如果 `ident` 是一个被解析的标识符，那么这段的 `my_ident` 会继承 ident 的范围
let my_ident = format_ident!(&quot;My{}{}&quot;, ident, &quot;IsCool&quot;);
assert_eq!(my_ident, &quot;MyIdentIsCool&quot;);
</code></pre>
<ul>
<li>当无标识符可提供时，默认调用 
<a href="https://docs.rs/proc-macro2/*/proc_macro2/struct.Span.html#method.call_site"><code>Span::call_site</code></a>
表示当前过程宏被调用的范围</li>
</ul>
<pre><code class="language-rust ignore">format_ident!(&quot;MyIdent&quot;)
</code></pre>
<ul>
<li>也可以使用 <code>span = </code> 指定范围</li>
</ul>
<pre><code class="language-rust ignore">let my_span = /* ... */;
format_ident!(&quot;MyIdent&quot;, span = my_span);
</code></pre>
<h2 id="quote-与-totokens"><a class="header" href="#quote-与-totokens"><code>quote!</code> 与 <code>ToTokens</code></a></h2>
<h3 id="基础知识-1"><a class="header" href="#基础知识-1">基础知识</a></h3>
<p><code>quote!</code> 是整个 <code>quote</code> crate 提供的最主要的功能：</p>
<ol>
<li>该宏进行变量插值：任何实现了 <code>ToTokens</code> trait 的类型都能插值</li>
<li>宏的结果为 <code>proc_macro2::TokenStream</code> 类型：如果要返回给编译器（即作为过程宏的输出），则使用 <code>.into()</code> 或者 
<code>proc_macro::TokenStream::from</code> 把它转化为 <code>proc_macro::TokenStream</code> 类型</li>
</ol>
<p>一个 derive 过程宏的代码框架：</p>
<pre><code class="language-rust ignore">use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(MyMacro)]
pub fn my_macro(input: TokenStream) -&gt; TokenStream {
    // Parse the input tokens into a syntax tree
    let input = parse_macro_input!(input as DeriveInput);

    // Build the output, possibly using quasi-quotation
    let expanded = quote! {
        // ...
    };

    // Hand the output tokens back to the compiler
    TokenStream::from(expanded)
}
</code></pre>
<p>函数内的代码就是我们编写过程宏的主体，完成了过程宏的第 2 步：处理和生成标记流。具体来说：</p>
<ol>
<li><code>syn::parse_macro_input!</code> 把获取到的标记流转化成实现了 <code>syn::parse::Parse</code> 的类型</li>
<li>然后基于 <code>syn</code> 丰富的数据结构，处理标记流</li>
<li>利用 <code>quote::quote!</code> 把标记流重组成 <code>proc_macro2::TokenStream</code>，其间可把实现了 <code>quote::ToTokens</code> 的数据插值</li>
<li>最后把 <code>proc_macro2::TokenStream</code> 转化成 
<code>proc_macro::TokenStream</code><sup class="footnote-reference"><a href="#proc_macro2-proc_macro::TokenStream">4</a></sup>，它们之间实现了
<a href="https://docs.rs/proc-macro2/*/proc_macro2/struct.TokenStream.html#impl-From%3CTokenStream%3E">双向转化</a></li>
</ol>
<div class="footnote-definition" id="proc_macro2-proc_macro::TokenStream"><sup class="footnote-definition-label">4</sup>
<p>这一步很好理解，因为过程宏的函数签名只有
<code>proc_macro::TokenStream</code>。此外，一个基本事实是，忽略 <a href="https://docs.rs/unicode-xid"><code>unicode-xid</code></a> 
依赖，<code>proc_macro2</code> 对 <code>proc_macro</code> 进行了包装，<code>quote</code> 基于和拓展了 <code>proc_macro2</code> 的功能，而 
<code>syn</code> 基于和拓展了 <code>quote</code> 与 <code>proc_macro2</code>。</p>
</div>
<h3 id="插值"><a class="header" href="#插值">插值</a></h3>
<p><code>quote!</code> 使用 <code>#var</code> 语法插值，这类似于 <code>macro_rules!</code> 的 <code>$var</code> 
插值方式。这里说的“插值”，具体指：把当前作用域里的变量 <code>var</code> 插入到输出标记的某处。</p>
<p>具体能插入哪些东西呢？或者说如何控制插入的标记的含义呢？</p>
<p>与声明宏使用 13 种分类片段符 
(<a href="https://zjp-cn.github.io/tlborm/macros/minutiae/fragment-specifiers.html">fragment specifiers</a>) 
进行解析和生成标记的做法不同，过程宏使用了不同的方式<sup class="footnote-reference"><a href="#ToTokens">5</a></sup>：使用
<a href="https://docs.rs/syn/latest/syn/parse/index.html"><code>syn::parse</code></a> 解析标记，并使用 <a href="https://docs.rs/quote/latest/quote/trait.ToTokens.html"><code>quote::ToTokens</code></a>
trait 生成标记。</p>
<p>任何实现了 <code>ToTokens</code> 的类型都能通过 <code>quote!</code> 插值，而且至少有以下类型：</p>
<ol>
<li>在 <code>quote::ToTokens</code> 实现了的 Rust 大部分的原始类型：各种数值、常用字符串、bool、Option、Box、Rc 等</li>
<li>在 <code>quote::ToTokens</code> 实现了的 <code>proc_macro2</code> 的主要类型：Group、Ident、Punct、Literal、TokenTree、TokenStream</li>
<li><code>syn</code> 内定义的<a href="https://docs.rs/syn/latest/syn/macro.parse_macro_input.html?search=totokens">大部分类型</a></li>
</ol>
<div class="footnote-definition" id="ToTokens"><sup class="footnote-definition-label">5</sup>
<p>事实上，<code>quote!</code> 自身是一个声明宏，而且只以 <code>tt</code> 分类符的方式匹配任意多的标记，其背后也大量使用声明宏。</p>
</div>
<p>与声明宏的<a href="https://zjp-cn.github.io/tlborm/patterns/repetition-replacement.html">反复替换</a>功能类似，<code>quote!</code>
也支持反复插值，但有以下特点：</p>
<ul>
<li>反复插值其实是在迭代每个元素时，给每个元素插入一份<abbr title="repetition body">重复体</abbr>的代码副本</li>
<li><code>var</code> 可以是任意满足 <code>Iterator</code> 和 <code>ToTokens</code> 要求<sup class="footnote-reference"><a href="#ToTokens-Iterator">6</a></sup>的类型：比如 <code>Vec</code>、<code>BTreeSet</code>、实现了
<code>Iterator::Item: ToTokens</code> 的迭代器类型</li>
<li>语法（例子）：
<ul>
<li><code>#(#var)*</code></li>
<li><code>#(#var),*</code> ⇒ 每一项之间用 <code>,</code> 分隔</li>
<li><code>#( struct #var; )*</code>、<code>#( + #var; )*</code> ⇒ 可以包含其他标记</li>
<li><code>#( #k =&gt; println!(&quot;{}&quot;, #v), )*</code> ⇒ 一次包含多个插值</li>
</ul>
<pre><code class="language-rust ignore">// lib.rs
use quote::quote;
use proc_macro::TokenStream;

#[proc_macro]
pub fn test(_: TokenStream) -&gt; TokenStream {
    let range = 1..4;
    let q = quote!( 0 #(+ #range)*);
    println!(&quot;{}&quot;, q); // 0 + 1i32 + 2i32 + 3i32
    dbg!(q).into() // q = TokenStream [ ... ]
}

// main.rs
fn main() {
    let q = path_to::test!();
    dbg!(q); // q = 6
}
</code></pre>
</li>
</ul>
<div class="footnote-definition" id="ToTokens-Iterator"><sup class="footnote-definition-label">6</sup>
<p>这里的实现细节有些复杂，感兴趣的话见<a href="https://docs.rs/quote/*/src/quote/runtime.rs.html">源码</a>。一个特例是
<code>Vec</code>，它没有实现 <code>ToTokens</code>，但它依然可用于反复插值。</p>
</div>
<h3 id="卫生性"><a class="header" href="#卫生性">卫生性</a></h3>
<ol>
<li>所有被插值的标记保留了其 <code>ToTokens</code> 实现提供的 <code>Span</code> 信息</li>
<li><code>quote!</code> 生成的非插值标记的 <code>Span</code> 为
<a href="https://docs.rs/proc-macro2/1.0/proc_macro2/struct.Span.html#method.call_site"><code>Span::call_site()</code></a></li>
<li>如果需要生成不同于上述 <code>Span</code> 的标记，需使用 <a href="https://docs.rs/quote/*/quote/macro.quote_spanned.html"><code>quote_spanned!</code></a></li>
</ol>
<h3 id="细节补充"><a class="header" href="#细节补充">细节补充</a></h3>
<ul>
<li><code>quote</code> 和 <code>syn</code> 是好搭档，你可以在 <code>syn</code> 的 <a href="https://github.com/dtolnay/syn/tree/master/examples">examples</a> 下找到实操的综合例子</li>
<li>你可以把最终生成的 <code>proc_macro2::TokenStream</code> 拆成多个部分，即利用插值把局部标记组合起来，比如：
<pre><code class="language-rust ignore">let type_definition = quote! {...};
let methods = quote! {...};

let tokens = quote! {
<span class="boring">    type_definition
</span><span class="boring">    methods
</span>};
</code></pre>
</li>
<li>把构造标识符的步骤放到 <code>quote!</code> 之前：
<pre><code class="language-rust ignore">// 错误做法：在 `quote!` 内部构造标识符并不会把各部分标识符拼接起来
// `_` 和 `ident` 代表的标识符不会组合成一个，如果 `ident` 代表 `x`，那么这如同 `_ x`  
quote! { let mut _#ident = 0; } 

// 正确做法：在 `quote!` 内只保存 `#var` 语法，就如同引用一样 （quasi-quoting）
let varname = format_ident!(&quot;_{}&quot;, ident);
quote! { let mut #varname = 0; }

// 正确做法
let concatenated = format!(&quot;_{}&quot;, ident);
let varname = syn::Ident::new(&amp;concatenated, ident.span());
quote! { let mut #varname = 0; }
</code></pre>
</li>
<li>调用方法时，尤其是泛型方法，使用 <code>&lt;Type&gt;::func()</code> 语法插值，如：
<pre><code class="language-rust ignore">// 错误做法：虽然这有时可以生效（比如 `field_type` 是 `String`）
// 但如果 `field_type` 是 `Vec&lt;i32&gt;`，那么这种方法如同手写的 `Vec&lt;i32&gt;::new()`
// 而正确写法应为 `Vec::&lt;i32&gt;::new()` 或者 `&lt;Vec&lt;i32&gt;&gt;::new()`
// 即使为 `String`，这种 `&lt;String&gt;::new()` 语法实际也是正确的
quote! { let value = #field_type::new(); }

// 正确做法
quote! { let value = &lt;#field_type&gt;::new(); }

// 正确做法
quote! { let value = &lt;#field_type as core::default::Default&gt;::default(); }
</code></pre>
</li>
<li>在文档注释中插值：
<pre><code class="language-rust ignore">// 错误做法：这不会把 `#ident` 的值插入进来
quote! {
    /// try to interpolate: #ident
    ///
    /// ...
}

// 错误做法：这不会把 `#ident` 的值插入进来
quote! { #[doc = &quot;try to interpolate: #ident&quot;] }

// 错误做法：`#[doc]` 属性在 `quote!` 中不支持调用宏（比如这里的 `stringify!` 以及 `include_str!`）
quote! { #[doc = concat!(&quot;try to interpolate: &quot;, stringify!(#ident))] }

// 正确做法：把需要插入的值（甚至那所涉及的部分）放入变量，使用 `#[doc = #msg]` 语法插值
let msg = format!(...);
quote! {
    #[doc = #msg]
    ///
    /// 其他无需插值的注释内容...
}
</code></pre>
</li>
<li>使用 <a href="https://docs.rs/syn/1.0/syn/struct.Index.html"><code>syn::Index</code></a> 对元组或者元组结构体索引插值：
<pre><code class="language-rust ignore">// 错误做法
let i = 0usize..self.fields.len();
// 以下代码会展开成不正确的语法 `0 + self.0usize.heap_size() + self.1usize.heap_size() + ...` 
quote! { 0 #( + self.#i.heap_size() )* }

// 正确做法
let i = (0..self.fields.len()).map(syn::Index::from);
// 以下代码展开成正确的语法 `0 + self.0.heap_size() + self.1.heap_size() + ...`
quote! { 0 #( + self.#i.heap_size() )* }
</code></pre>
</li>
</ul>
<h2 id="quote_spanned"><a class="header" href="#quote_spanned"><code>quote_spanned!</code></a></h2>
<p><code>quote_spanned!</code> 与 <code>quote!</code> 的唯一区别在于“<a href="quote-syn.html#%E5%8D%AB%E7%94%9F%E6%80%A7">卫生性</a>”，即 <code>quote_spanned!</code> 可以手动指明 <code>span</code>：</p>
<pre><code class="language-rust ignore">quote_spanned! {span=&gt;
    // 这里的内容与 `quote!` 一致，也有插值功能
};
</code></pre>
<p><code>span=&gt;</code> 是作者倡导的一种的书写方式，用以表明 span 表达式在过程宏的上下文中求值，而剩余的标记在生成的代码中求值。</p>
<p>关于 <code>quote!</code>、<code>quote_spanned!</code> 和声明宏的实际案例，见 <a href="./study-case.html#assert_sync"><code>assert_sync!</code></a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../proc/ref.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../proc/syn.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../proc/ref.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../proc/syn.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../theme/pagetoc.js"></script>
    </body>
</html>
